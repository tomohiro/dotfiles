<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>循環の収集</title>

 </head>
 <body><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="features.gc.refcounting-basics.html">参照カウント法の原理</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="features.gc.performance-considerations.html">パフォーマンスの考慮点</a></div>
 <div class="up"><a href="features.gc.html">ガベージコレクション</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="features.gc.collecting-cycles" class="sect1">
   <h2 class="title">循環の収集</h2>
   <p class="para">
    伝統的に、PHP で以前使われていたような参照カウント法記憶機構では、
    循環参照メモリ・リークに対処できません。
    しかしながら、5.3.0 現在、PHP ではその問題に焦点を当てた
    <a href="http://www.research.ibm.com/people/d/dfb/papers/Bacon01Concurrent.pdf" class="link external">&raquo; Concurrent Cycle Collection in Reference Counted Systems</a>
    レポートに由来する同期アルゴリズムを実装しています。
   </p>
   <p class="para">
    アルゴリズムの動作方法の詳しい説明がこのセクションの範囲の少し向こうにあります、
    しかし、基本はここで説明されます。
    まず第一に、いくつかの基本原則を確立しなければなりません。
    refcount が増やされたら、それはまだ使用中で、従ってゴミではありません。
    refcount が減少して、ゼロに達したら、zvalは解放可能です。
    refcount 引数がゼロ以外の値に減少する場合、これは、ガベージサイクルを作成できる
    だけであることを意味します。
    第２に、ガベージサイクルで、それらの refcount を減少させられるかどうかチェック
    することによって、どの部分がゴミか発見できます。
    可能です、そして、zval のうちいずれがゼロの refcountを持つか調べます。
   </p>
   <p class="para">
     <div class="mediaobject">
      
      <div class="imageobject">
       <img src="images/12f37b1c6963c1c5c18f30495416a197-gc-algorithm.png" alt="ガベージコレクションのアルゴリズム" width="614" height="814" />
      </div>
     </div>
   </p>
   <p class="para">
    To avoid having to call the checking of garbage cycles with every possible
    decrease of a refcount, the algorithm instead puts all 可能性があるルート
    (zvals) in the &quot;root buffer&quot; (marking them &quot;purple&quot;). It also makes sure
    that each possible garbage root ends up in the buffer only once.
    ルート・バッファが満杯の場合だけ、内部のそれぞれの zval 全てに対して収集機構が動き出します。
    上図のステップ A をご覧ください。
   </p>
   <p class="para">
    ステップ B では、
    the algorithm runs a depth-first search on all 可能性があるルート
    to decrease by one the refcounts of each zval it finds, making sure not to
    decrease a refcount on the same zval twice (by marking them as &quot;grey&quot;). In
    step C, the algorithm again runs a depth-first search from each root node,
    to check the refcount of each zval again.
    refcount がゼロと分かった場合、zval は「白」（図では青色です）とマークされます。
    If it&#039;s larger than
    zero, it reverts the decreasing of the refcount by one with a depth-first
    search from that point on, and they are marked &quot;black&quot; again. In the last
    step (D), the algorithm walks over the root buffer removing the zval roots
    from there, and meanwhile, checks which zvals have been marked &quot;white&quot; in
    the previous step.
    「白」としてマークされた zval が全て解放されます。
   </p>
   <p class="para">
    アルゴリズムが動作する方法の基礎を理解したので、
    これと PHP を統合する方法を振り返りましょう。
    デフォルトで、PHP のガベージコレクタは有効です。
    しかしながら、これを変更できる <var class="filename">php.ini</var> の設定があります。
    （それは） <strong class="option unknown">zend.enable_gc</strong>
 です。
   </p>
   <p class="para">
    ガベージコレクタがオンの場合、
    ルート・バッファが満杯になるといつでも、先に述べたように循環検出法が実行されます。
    ルート・バッファでは、可能性があるルートのサイズが一万件に固定されています。
    （PHP のソースコードの <i>Zend/zend_gc.c</i> で
    <i>GC_ROOT_BUFFER_MAX_ENTRIES</i> 定数を変更して、PHP を再コンパイルすると変更できます）
    ガベージコレクタがオンの場合、循環検出法は実行されません。
    しかしながら、可能性があるルートはルート・バッファに常に記録されます。
    ガベージコレクション機構がこの構成設定値で起動したかどうかは問題ではありません。
   </p>
   <p class="para">
    ガベージコレクション機構がオフの時に、可能性があるルートでルート・バッファが満杯になると、
    可能性があるルートは単にそれ以上記録されません。
    記録されないそれらの可能性があるルートは、アルゴリズムによって決して分析されません。
    もしそれらが循環参照サイクルの要素ならば、
    それらは決してクリーンアップされないで、メモリリークを生み出します。
   </p>
   <p class="para">
    たとえ機構が無効だとしても、可能性があるルートが記録される理由は、
    可能性があるルートが見つかるたびに機構がオンかどうかチェックしなければいけないよりも、
    可能性があるルートを記録するほうが速いからです。
    しかしながら、ガベージコレクションと分析機構そのものにかなりの時間がかかることがあります。
   </p>
   <p class="para">
    <strong class="option unknown">zend.enable_gc</strong>
 構成設定値を変える他に、
    <span class="function"><a href="function.gc-enable.html" class="function">gc_enable()</a></span> や <span class="function"><a href="function.gc-disable.html" class="function">gc_disable()</a></span> をそれぞれ呼ぶことでも、
    ガベージコレクション機構をオン／オフできます。
    それらの機能を呼ぶことと、構成設定値で機構をオン／オフすることには同じ影響があります。
    たとえ可能性があるルートのバッファがまだ満杯でなくても、
    循環の収集を強制することもできます。
    このために、<span class="function"><a href="function.gc-collect-cycles.html" class="function">gc_collect_cycles()</a></span> 関数を使用できます。
    この関数は、アルゴリズムによって収集された循環の数を返します。
   </p>
   <p class="para">
    The rationale behind the ability to turn the mechanism on and off, and to
    initiate cycle collection yourself, is that some parts of your application
    could be highly time-sensitive.
    それらの場合、ガベージコレクション機構が有効にならないほうが良いかもしれません。
    Of course, by turning off the
    garbage collection for certain parts of your application, you do risk
    creating memory leaks because some 可能性があるルート might not fit into the
    limited root buffer. 
    従って、ルート･バッファにすでに記録された、可能性があるルートを通じて失われる可能性のあるメモリを解放するために、
    <span class="function"><a href="function.gc-disable.html" class="function">gc_disable()</a></span> を呼ぶ直前に <span class="function"><a href="function.gc-collect-cycles.html" class="function">gc_collect_cycles()</a></span>
    を呼ぶことは多分賢いでしょう。
    そうすると、循環収集機構がオフの間、
    可能性があるルートを保管するためのより多くの空間のための空のバッファが残ります。
   </p>
  </div><hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="features.gc.refcounting-basics.html">参照カウント法の原理</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="features.gc.performance-considerations.html">パフォーマンスの考慮点</a></div>
 <div class="up"><a href="features.gc.html">ガベージコレクション</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
